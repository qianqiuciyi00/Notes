# Cookie
- 设置：Set-Cookie
- 生命周期：  
  1.会话期Cookie：浏览器关闭之后会自动删除，仅在会话期内有效。不需要指定过期时间（Expires）或有效期（Max-Age）。但是有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期Cookie也会被保留下来，就好像浏览器从来没有关闭一样，这会导致Cookie的生命周期无限延长  
  2.持久性Cookie的生命周期取决于过期时间和有效期指定的一段时间
- 限制访问Cookie  
  有两种方法可以确保Cookie被安全发送，并且不会被意外的参与者或脚本访问：Secure属性和HttpOnly属性
  - 标记Secure的cookie只应通过被HTTPS协议加密过的请求发送给服务端
  - JavaScript`Document.cookie`API无法访问带有HttpOnly属性的cookie，此类cookie仅作用于服务器。此预防措施有助于缓解跨站脚本攻击(XSS)
- Cookie的作用域  
  Domain和Path标识定义了COokie的作用域：即允许Cookie应该发送给哪些URL
  - Domain: 指定了哪些主机可以接受cookie，如果不指定，默认为origin，**不包含子域名**。如果指定了Domain，则一般包含子域名
  - Path：指定了主机下的哪些路径可以接受cookie（该URL路径必须存在于请求URL中）。以（"/"）作为路径分隔符，子路径也会被匹配
  - SameSite：cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击。它有三个值：
    1.**None**：浏览器会在同站请求、跨站请求下继续发送cookie，不区分大小写  
    2.**Strict**：浏览器将只在访问相同站点时发送cookie  
    3.**Lax**：与**Strict**类似，但用户从外部站点导航至URL时除外（例如通过连接）。在新版本浏览器中为默认选项。
  
# 缓存
- 概述  
良好的缓存策略可以降低资源的重复加载挺高王爷的整体加载速度，通常浏览器缓存策略分为两种：强缓存和协商缓存  
1、基本原理  
 - 浏览器在加载资源时，根据请求头的`expires`和`cache-control`判断是否命中强缓存，是则直接从缓存读取资源，不会发送请求到服务器
 - 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然从缓存中读取资源
 - 如果前两者都没有命中，直接从服务器加载资源  
2、相同点  
如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据  
3、不同点  
强缓存不发送请求到服务器，协商缓存会发请求到服务器

- 强缓存
通过**Expires**和**Cache-Control**两种响应头实现  
1、Expires  
Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。Expires受限于本地时间，如果修改了本地时间，可能会造成缓存失败  
2、Cache-Control  
出现于http/1.1，优先级高于Expires，表示的是相对时间
```
Cache-Control:max-age=31350000
```
`Cache-control:no-store`：不缓存数据到本地
`Cache-Control:public`：可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
`Cache-Control:private`：只能被终端浏览器缓存（而且是私有缓存），不允许中间缓存服务器进行缓存

- 协商缓存  
如果命中协商缓存则请求响应返回的http状态码为304并且会显示一个Not Modified的字符串  
协商缓存是利用`【Last-Modified,If-Modified-Since】`和`【ETag,If-None-Match】`这两对header来管理的  
1、Last-Modified，If-Modified-Since  
`Last-Modified`表示本地文件最后修改日期，浏览器会在request header加上`If-Modified-Since`（删除给返回的`Last-Modified`）的值，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来  
但是如果在本地打开缓存文件，就会造成Last-Modified被修改，所以出现了ETag  
2、ETag, If-None-Match  
`ETag`就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，`ETag`可以保证每一个资源是唯一的  
`If-None-Match`的header会将上次返回的`ETag`发送给服务器，询问该资源的`ETag`是否有更新，有变动就会发送新的资源回来  
`ETag`的优先级比`Last-Modified`高，使用`ETag`的原因：
  - 一些文件也许会周期性的更改，但是它的内容并不改变，这个时候我们并不希望客户端认为这个文件被修改了，而重新获取
  - 某些文件修改非常频繁，If-Modified-Since能见查到的粒度是s级的，这种修改无法判断
  - 某些服务器不能精确的得到文件的最后修改时间

- 整体流程图
![RUNOOB 图标](https://user-images.githubusercontent.com/25027560/38223505-d8ab53da-371d-11e8-9263-79814b6971a5.png)

- 几种状态码的区别
  - 200：强缓存Expires/Cache-COntrol失效时，返回新的资源文件
  - 200(from cache)：强缓存Expires/Cache-control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功
  - 304(Not Modified)：协商缓存Last-Modified/ETag没有过期时，服务端返回状态码304
注：现在的200(form cache)变成了from disk cache(磁盘缓存)和from memory cache(内存缓存)两种

# HTTP协议特点
- 支持客户/服务器模式
- 简单快速：客户端向服务器请求服务时，只需传动请求方式和路径
- 灵活：HTTP允许传输任意类型的数据对象
- 无连接：限制每次连接只处理一个请求，服务器处理完客户端的请求，并受到客户端的应答后，即断开连接，采用这种方式可以节省传输时间
- 无状态：协议对于事务处理没有记忆能力

# 与HTTP相关的协议
- TCP/IP 是网路世界最常用的协议，HTTP通常运行在TCP/IP提供的可靠传输基础上。  
  IP协议是Internet Protocol的缩写，主要目的是**解决寻址和路由问题，以及如何在两点间传送数据包**。IP协议使用IP地址的概念来定位互联网上的每一台计算机。  
  TCP协议是Transmission Control Protocol 的缩写，意思是传输控制协议，它位于IP协议之上，基于IP协议提供可靠的、字节流形式的通信，是HTTP协议得以实现的基础。  
  **可靠**是指保证数据不丢失，**字节流**是指保证数据完整，所以在TCP协议的两端可以如同操作文件一样访问传输的数据，就像在读写一个密闭的管道里的 流动  的字节  
- DNS域名是IP地址的等价替代，需要用域名解析实现到IP地址的映射  
  域名系统 （Domain Name System），用有意义的名字来作为IP地址的等价替代。在DNS种，域名Domain Name 又称为主机名（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。  
  域名用`.`分割成多个单词，级别从左到右逐级升高，最右边的被称为**顶级域名**。例如表示商业公司的`com`，表示教育机构的`edu`，表示国家的`cn`,`uk`等  
  但是想要使用TCP/IP协议来通信仍然要使用IP地址，所以需要把域名做一个转换，映射到他的真实IP，这就是**域名解析**
- URI是用来标记互联网上资源的一个名字，由 `协议名 + 主机名 + 路径`构成，俗称URL  
  URI（Uniform Resource Identifier），**统一资源标识符**，使用它能够唯一地标记互联网上资源  
  URL（Uniform Resource Locator），**统一资源定位符**，也就是俗称的网址，它实际上是URI地一个字迹，不过这两者几乎是相同的，差异不大，所以通常不会做严格的区分  
  ```
  http:nginx.org/en/download.html
  ```
  URI主要由三个基本的部分构成：  
  - 协议名：访问该资源使用的协议，在这里是http
  - 主机名：互联网上主机的标记，可以是域名或IP地址，这里是nginx.org
  - 路径：资源在主机上的位置，使用`/`分隔多级目录，这里是/en/download.html
- HTTPS相当于 `HTTP + SSL/TLS + TCP/IP`，为HTTP套了一个安全的外壳  
  HTTPS 全称是HTTP over SSL/TLS，也就是运行在SSL/TLS协议上的HTTP。SSL/TLS是一个**负责加密通信的安全协议**，建立在TCP/IP之上，所以也是个可靠的传输协议，可以被用作HTTP的下层。  
  HTTPS 相当于`HTTP + SSL/TLS + TCP/IP`  
  SSL的全称是`Secure Socket Layer`，由网景公司发明，当发展到3.0时被标准化，改名为TLS，即`Transport Layer Security`，但由于历史原因很多人成为SSL/TLS，或者直接简称为SSL  
  SSL 是用了很多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为HTTP套上一副坚固的盔甲
- 代理是HTTP传输过程中的中转站，可以实现缓存加速、负载均衡等功能  
  代理（Proxy）是HTTP协议中请求方和应答方中间的一个环节，作为中转站，既可以转发客户端的请求，又可以转发服务器的应答。  
  代理有很多种类，常见的有：  
  - 匿名代理：完全隐匿了被代理的机器，外界看到的只是代理服务器
  - 透明代理：在传输过程中是透明开放的，外界既知道代理，又知道客户端
  - 正向代理：靠近客户端，代表客户端向服务器发送请求
  - 反向代理：靠近服务器，代表服务器响应客户端的请求  

  由于代理在传输过程中插入了一个中间层，所以可以在这个环节做很多有意思的事情，比如：
  - 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化
  - 内容缓存：暂存上下行的数据，减轻后端的压力
  - 安全防护：隐匿IP，使用WAF等工具抵御网络攻击，保护被代理的机器
  - 数据处理：提供压缩、加密等额外的功能

# CDN
CDN(内容分发网络)指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据那些服务器与用户距离最近，来满足数据的请求。CDNS提供快速服务，较少受高流量影响  
CDNS被广泛用于传输style sheets 和JavaScript等静态资源，像bootstrap，jQuery等，对这些库文件使用CDN技术，有以下几点好处：
- 通过CDN向用户分发传输相关库的静态资源文件，可以降低我们自身服务器的请求压力
- 大多数CDN在全球都有服务器，所以CDNs上的服务器在地理位置上可能比你自己的服务器更接近你的用户。地理距离会按比例影响延迟
- CDNs已经配置了恰当的缓存设置。使用CDN节省了在你的服务器中对静态资源文件的配置  
优化加载静态资源速度的机制：  
1.资源调度：CDN会根据用户接入网络的ip寻找距离用户最优路径的服务器。调度的方式主要有DNS调度、http302调度、使用HTTP进行的DNS调度（多用于移动端）  
2.缓存策略和数据检索：CDN服务器实用高效的算法和数据结构，快速的检索资源和更新读取缓存  
3.网络优化：从OSI七层模型进行优化，达到网络优化的目的  
- L1物理层：硬件设备升级提高速度
- L2数据链路层：寻找更快的网络节点，确保Lastmile尽量短
- L3路由层：路径优化，寻找两点间最优路径
- L4传输层：协议TCP优化，保持长连接、TCP快速打开
- L7应用层：静态资源压缩、请求合并