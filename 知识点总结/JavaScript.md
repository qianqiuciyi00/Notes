# DOMContentLoaded
- 当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完全加载。如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等待CSSDOM构建完成才能执行。在任何情况下，DOMContentLoaded的触发不需要等待图片等其他资源加载完成。
- 使用
  ```js
    document.addEventListener('DOMContentLoaded', function(event) {
        ...
    })
  ```

# 异步脚本
- async 或defer
  当HTML文档被解析时如果遇见同步脚本，则停止解析，先去加载脚本，然后执行，执行结束后继续解析HTML文档。
- defer脚本：
  当HTML文档被解析时如果遇见defer脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer脚本执行。另外，defer脚本的执行顺序与定义时的位置有关系。
- async脚本：
  当HTML文档被解析时如果遇见async脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束之后文档继续解析。

# 异步脚本与DOMContentLoaded
- defer：DOMContentLoaded 只有在defer脚本执行结束之后才会被触发
- async: HTML文档构建不受影响，解析完毕后，DOMContentLoaded触发，而不需要等待adync脚本执行、样式表加载等等。

# MutationObserver
- MutationObserver是一个内建对象，它观察DOM元素，并在检测到更改时触发回调

# Source Map
JavaScript大部分源码都需要经过转换才能投入生产环境。常见的源码转换场景：  
1、压缩，减小体积  
2、多个文件合并，减少HTTP请求数  
3、其他语言编译成JavaScript。  
source map 是一个信息文件，里面储存着位置信息，也就是转换后代码的每一个位置，和所对应转换前的位置。这样，在生产环境报错时将能直接看到原始代码，方便调试

# 事件循环
1、为什么JavaScript是单线程  
与他的用途有关，作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。假如JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器该以哪个线程为准呢？所以，为了避免复杂性，JavaScript就是单线程，以后也不会改变。  
2、任务队列  
单线程意味着，所有任务都需要排队，前一个任务结束，才会执行后一个任务。在等待任务执行完成的时候，有的CPU是闲着的，可以先挂起处于等待中的任务，先运行排在后面的任务，等到前一个任务有了结果，再回过头，把挂起的任务继续执行下去。
于是，所有任务可以分成两种，一种是同步任务，另一种是异步任务。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程，而进入“任务队列”的任务，只有“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行  
异步执行的运行机制如下（同步执行也是如此，因此它可以被视为没有异步任务的异步执行）
```
1、所有同步任务都在主线程上执行，形成一个执行栈
2、主线程之外，还存在一个“任务队列”，只要异步任务有了运行结果，就在“任务队列”之中放置一个事件
3、一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
4、主线程不断重复上面的第三步
```
3、Event Loop
主线程从“任务队列”中读取事件，这个过程是不断循环的，所以整个的这个运行机制又称为Event Loop（事件循环）

# 栈和堆的概念和区别，垃圾回收时的区别
- 概念  
  栈：是栈内存的简称，栈是自动分配相对固定大小的内存空间，并由系统自动释放，栈数据结构遵循先进后出的原则  
  堆：是堆内存的简称，堆是动态分配内存，内存大小不固定，也不会自动释放，堆数据结构是一种无序的树状结构，同时它还满足key-value键值对的存储方式  
  栈的特点：速度快，容量小  
  堆的特点：速度稍慢，容量比较大  
- 基本类型和引用类型
![内存 内存](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/23/17379552d18f1b91~tplv-t2oaga2asx-watermark.awebp)  
**基本数据类型**直接存放在栈内存中，占用的内存空间的大小是确定的，并由系统自动分配和自动释放。这样的好处就是，内存可以及时得到回收，相对于堆来说，更加容易管理内存空间  
**引用数据类型**：指那些可能由多个值构成的对象；如Object、Array、Function，他们是通过拷贝和new出来的，这样的数据存储在堆中  

- 传值和传址的区别  
**基本类型**：采用的是值传递  
**引用类型**：采用地址传递  
引用类型的数据的地址指针是存储在栈中的，将存放在栈内存中的地址赋值给接收的变量。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后再通过地址指针找到堆中的所需要的数据（保存在堆内存中，包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针）
- 内存分配垃圾回收  
1.内存分配  
- 栈内存：线性有序存储，容量小，系统分配效率高
- 堆内存：首先要在顿内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对要低些
2.立即回收  
- 栈内存：变量基本上用完就回收了，相对于堆呢来说存取速度会快，并且栈内存中的数据是可以共享的
- 堆内存：堆内存中的对象不会随方法的结束而销毁，就算方法结束了，这个对象也可能会被其他引用变量所引用（参数传递）。创建对象是为了反复利用（因为对象的创建成本通常较大），这个对象将被保存到运行时数据区（也就是堆内存）。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

# 内存泄漏
- 不再使用的内存，没有及时释放，就叫做内存泄漏。
- 垃圾回收机制  
  最常用的方法叫做“引用计数”，语言引擎有一张“引用表”，保存了内存里面所有的资源的引用次数。如果一个值的引用次数是0，则表示这个值不再用到了，那么就可以将这块内存释放。  
  如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏
- WeakMap  
  ES6推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，Weak表示弱引用

# Object.is()
判断两个值是否为同一个值，返回Boolean类型
```
Object.is(val1, val2)
```
如果满足以下条件则两个值相等：  
- 都是undefined
- 都是null
- 都是true或false
- 都是相同长度的字符串且相同字符按相同顺序排列
- 都是相同对象（意味着每个对象都有同一个引用）
- 都是数字且  
  - 都是+0
  - 都是-0
  - 都是NaN
  - 都是非零而且非NaN且为同一个值

与 == 的区别：==运算符在判断相等前对两边的变量（如果他们不是同一类型）进行强制转换，而Object.is()不会强制转换两边的值  
与 === 的区别：=== 运算符将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等

# for in 、for of 和 Object.keys()的区别
- for in ：遍历对象所有可枚举属性，包括原型链上的属性。（数组，对象）
- for of： 主要便利可迭代的对象（Array, Map, Set, argument等）用来获取对象的属性值，返回属性值
- Object.keys()：遍历对象所有可枚举属性，不包括原型链上的属性，返回一个数组（数组，对象）
- Object.getPropertyNames()：返回除原型属性以外的所有属性（包括不可枚举属性）名组成的数组（数组，对象）